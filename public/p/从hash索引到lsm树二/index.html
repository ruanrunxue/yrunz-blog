<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='前言 在上一篇文章《从Hash索引到LSM树（一）》中，我们通过append-only log的数据结构，实现了一个具备高写入性能的key-value数据库。append-only log之所以有很高的写入性能，主要得益于磁盘的顺序写入。这可能违反了我们对磁盘的认知，因为在我们的印象中，写磁盘总是很慢。其实不然，准确地说应该是随机写磁盘很慢，因为在写之前可能会进行多次寻址。如果只是顺序写磁盘，性能是非常的高，如下的一个ACM报告中显示，顺序写磁盘甚至比随机写内存的性能还要高！
 举个例子，Kafka是一个高性能的消息队列，它的厉害之处就在于极致地利用磁盘的顺序写入性能，如果生产者和消费者的速率相当，消息甚至可以在操作系统的Page Cache层面就完成了传递。所以，以后别再认为写磁盘很慢了！
 append-only log大幅提升了数据写入性能，但是随之而来的是，非常低的数据读取性能。针对这一点，我们采用Hash索引进行了优化，优化的效果也非常的显著。然而，Hash索引有两个明显的限制：（1）当key的数量很多时，维护Hash索引会给内存带来很大的压力；（2）区间查询很低效。如何对这两个限制进行优化呢？这就轮到本文介绍的主角，LSM树，出场了。
LSM树（Log-Structured Merge Tree）并不是一种数据结构，准确来说是一种存储模型，由MemTable、Immutable MemTable、SSTable等部分组成。它也是利用了append-only log的优势，大幅提升了写入性能。同时，因为key的存储有序性，所以具备了不错的读取性能，也克服了上文所述Hash索引的两个限制。下面，本文将一步步分析LSM树是如何做到这一点的。
SSTable 在最简单的数据库例子中，因为数据是无序存储的，所以在读取某个key的值时，就需要遍历整个数据文件，算法复杂度是O(n)。为了提升读性能，我们不得不在内存中维护所有key的Hash索引。
假如存储数据时，对记录按照key进行排序的会怎样？
对于key有序存储这种情况，即使不用Hash索引，也能得到很好的查询效率，因为我们可以使用二分查找法（Binary Search）来快速找到key所在的位置，算法复杂度是O(logn)。LSM树正是采用key有序这种方式来组织数据存储的，并称之为SSTable。
SSTable（Sorted String Table）是LSM树最基础的一个存储结构，存储在磁盘中，并且数据按照key进行排序的。数据保持key有序的好处是可以在O(logn)的时间下，快速找到一个key值，相比于纯粹的append-only log有了很大的提升。但是，如果所有的数据都存储在一个SSTable上，数据量一大，查询效率也会下降。因此，LSM树通常会将数据分散存储在多个SSTable中，并且记录每个SSTable的最大key和最小key，这样就能快速定位到一个key存储在哪个SSTable上了。
// SSTable，数据保存到SSTable后只读不写 public class SSTable { ... // 数据存储路径  private final LogFile logFile; // 该SStable中存储的最小Key  private String minKey; // 该SStable中存储的最大Key  private String maxKey; // 使用二分查找法获取key值  public String get(String key) { // step1：先判断是否在SSTable的范围内  if (key.compareTo(minKey) &amp;lt; 0 || key.compareTo(maxKey) &amp;gt; 0) { return &amp;#34;&amp;#34;; } // step2：二分查找  long start = 0; long end = logFile.'><title>从Hash索引到LSM树（二）</title>

<link rel='canonical' href='https://www.yrunz.com/p/%E4%BB%8Ehash%E7%B4%A2%E5%BC%95%E5%88%B0lsm%E6%A0%91%E4%BA%8C/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='从Hash索引到LSM树（二）'>
<meta property='og:description' content='前言 在上一篇文章《从Hash索引到LSM树（一）》中，我们通过append-only log的数据结构，实现了一个具备高写入性能的key-value数据库。append-only log之所以有很高的写入性能，主要得益于磁盘的顺序写入。这可能违反了我们对磁盘的认知，因为在我们的印象中，写磁盘总是很慢。其实不然，准确地说应该是随机写磁盘很慢，因为在写之前可能会进行多次寻址。如果只是顺序写磁盘，性能是非常的高，如下的一个ACM报告中显示，顺序写磁盘甚至比随机写内存的性能还要高！
 举个例子，Kafka是一个高性能的消息队列，它的厉害之处就在于极致地利用磁盘的顺序写入性能，如果生产者和消费者的速率相当，消息甚至可以在操作系统的Page Cache层面就完成了传递。所以，以后别再认为写磁盘很慢了！
 append-only log大幅提升了数据写入性能，但是随之而来的是，非常低的数据读取性能。针对这一点，我们采用Hash索引进行了优化，优化的效果也非常的显著。然而，Hash索引有两个明显的限制：（1）当key的数量很多时，维护Hash索引会给内存带来很大的压力；（2）区间查询很低效。如何对这两个限制进行优化呢？这就轮到本文介绍的主角，LSM树，出场了。
LSM树（Log-Structured Merge Tree）并不是一种数据结构，准确来说是一种存储模型，由MemTable、Immutable MemTable、SSTable等部分组成。它也是利用了append-only log的优势，大幅提升了写入性能。同时，因为key的存储有序性，所以具备了不错的读取性能，也克服了上文所述Hash索引的两个限制。下面，本文将一步步分析LSM树是如何做到这一点的。
SSTable 在最简单的数据库例子中，因为数据是无序存储的，所以在读取某个key的值时，就需要遍历整个数据文件，算法复杂度是O(n)。为了提升读性能，我们不得不在内存中维护所有key的Hash索引。
假如存储数据时，对记录按照key进行排序的会怎样？
对于key有序存储这种情况，即使不用Hash索引，也能得到很好的查询效率，因为我们可以使用二分查找法（Binary Search）来快速找到key所在的位置，算法复杂度是O(logn)。LSM树正是采用key有序这种方式来组织数据存储的，并称之为SSTable。
SSTable（Sorted String Table）是LSM树最基础的一个存储结构，存储在磁盘中，并且数据按照key进行排序的。数据保持key有序的好处是可以在O(logn)的时间下，快速找到一个key值，相比于纯粹的append-only log有了很大的提升。但是，如果所有的数据都存储在一个SSTable上，数据量一大，查询效率也会下降。因此，LSM树通常会将数据分散存储在多个SSTable中，并且记录每个SSTable的最大key和最小key，这样就能快速定位到一个key存储在哪个SSTable上了。
// SSTable，数据保存到SSTable后只读不写 public class SSTable { ... // 数据存储路径  private final LogFile logFile; // 该SStable中存储的最小Key  private String minKey; // 该SStable中存储的最大Key  private String maxKey; // 使用二分查找法获取key值  public String get(String key) { // step1：先判断是否在SSTable的范围内  if (key.compareTo(minKey) &amp;lt; 0 || key.compareTo(maxKey) &amp;gt; 0) { return &amp;#34;&amp;#34;; } // step2：二分查找  long start = 0; long end = logFile.'>
<meta property='og:url' content='https://www.yrunz.com/p/%E4%BB%8Ehash%E7%B4%A2%E5%BC%95%E5%88%B0lsm%E6%A0%91%E4%BA%8C/'>
<meta property='og:site_name' content='元闰子的邀请'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='java' /><meta property='article:tag' content='数据库索引' /><meta property='article:tag' content='LSM' /><meta property='article:published_time' content='2020-07-28T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2020-07-28T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="从Hash索引到LSM树（二）">
<meta name="twitter:description" content="前言 在上一篇文章《从Hash索引到LSM树（一）》中，我们通过append-only log的数据结构，实现了一个具备高写入性能的key-value数据库。append-only log之所以有很高的写入性能，主要得益于磁盘的顺序写入。这可能违反了我们对磁盘的认知，因为在我们的印象中，写磁盘总是很慢。其实不然，准确地说应该是随机写磁盘很慢，因为在写之前可能会进行多次寻址。如果只是顺序写磁盘，性能是非常的高，如下的一个ACM报告中显示，顺序写磁盘甚至比随机写内存的性能还要高！
 举个例子，Kafka是一个高性能的消息队列，它的厉害之处就在于极致地利用磁盘的顺序写入性能，如果生产者和消费者的速率相当，消息甚至可以在操作系统的Page Cache层面就完成了传递。所以，以后别再认为写磁盘很慢了！
 append-only log大幅提升了数据写入性能，但是随之而来的是，非常低的数据读取性能。针对这一点，我们采用Hash索引进行了优化，优化的效果也非常的显著。然而，Hash索引有两个明显的限制：（1）当key的数量很多时，维护Hash索引会给内存带来很大的压力；（2）区间查询很低效。如何对这两个限制进行优化呢？这就轮到本文介绍的主角，LSM树，出场了。
LSM树（Log-Structured Merge Tree）并不是一种数据结构，准确来说是一种存储模型，由MemTable、Immutable MemTable、SSTable等部分组成。它也是利用了append-only log的优势，大幅提升了写入性能。同时，因为key的存储有序性，所以具备了不错的读取性能，也克服了上文所述Hash索引的两个限制。下面，本文将一步步分析LSM树是如何做到这一点的。
SSTable 在最简单的数据库例子中，因为数据是无序存储的，所以在读取某个key的值时，就需要遍历整个数据文件，算法复杂度是O(n)。为了提升读性能，我们不得不在内存中维护所有key的Hash索引。
假如存储数据时，对记录按照key进行排序的会怎样？
对于key有序存储这种情况，即使不用Hash索引，也能得到很好的查询效率，因为我们可以使用二分查找法（Binary Search）来快速找到key所在的位置，算法复杂度是O(logn)。LSM树正是采用key有序这种方式来组织数据存储的，并称之为SSTable。
SSTable（Sorted String Table）是LSM树最基础的一个存储结构，存储在磁盘中，并且数据按照key进行排序的。数据保持key有序的好处是可以在O(logn)的时间下，快速找到一个key值，相比于纯粹的append-only log有了很大的提升。但是，如果所有的数据都存储在一个SSTable上，数据量一大，查询效率也会下降。因此，LSM树通常会将数据分散存储在多个SSTable中，并且记录每个SSTable的最大key和最小key，这样就能快速定位到一个key存储在哪个SSTable上了。
// SSTable，数据保存到SSTable后只读不写 public class SSTable { ... // 数据存储路径  private final LogFile logFile; // 该SStable中存储的最小Key  private String minKey; // 该SStable中存储的最大Key  private String maxKey; // 使用二分查找法获取key值  public String get(String key) { // step1：先判断是否在SSTable的范围内  if (key.compareTo(minKey) &amp;lt; 0 || key.compareTo(maxKey) &amp;gt; 0) { return &amp;#34;&amp;#34;; } // step2：二分查找  long start = 0; long end = logFile.">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "light");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/yrz_hudc7c8721ecce4b724df5002339c76402_174377_300x0_resize_box_2.png" width="300"
                            height="306" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="https://www.yrunz.com">元闰子的邀请</a></h1>
        <h2 class="site-description">阅读、写作、生活（个人技术分享）</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>首页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>博客</span>
            </a>
        </li>
        
        

        <li >
            <a href='/%E5%85%B3%E4%BA%8E%E5%85%83%E9%97%B0%E5%AD%90/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24"
     viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
     stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z"/>
    <circle cx="12" cy="7" r="4"/>
    <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"/>
</svg>

                
                <span>关于元闰子</span>
            </a>
        </li>
        
        

        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-friends" width="44" height="44"
     viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <circle cx="7" cy="5" r="2"/>
    <path d="M5 22v-5l-1 -1v-4a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4l-1 1v5"/>
    <circle cx="17" cy="5" r="2"/>
    <path d="M15 22v-4h-2l2 -6a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1l2 6h-2v4"/>
</svg>

                
                <span>友情链接</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>暗色模式</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://www.yrunz.com" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/java/" >
                Java
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E4%BB%8Ehash%E7%B4%A2%E5%BC%95%E5%88%B0lsm%E6%A0%91%E4%BA%8C/">从Hash索引到LSM树（二）</a>
    </h2>

    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Jul 28, 2020</time>
    </footer></div>
</header>

    <section class="article-content">
    <h2 id="前言">前言</h2>
<p>在上一篇文章《从Hash索引到LSM树（一）》中，我们通过<strong>append-only log</strong>的数据结构，实现了一个具备高写入性能的key-value数据库。<strong>append-only log</strong>之所以有很高的写入性能，主要<strong>得益于磁盘的顺序写入</strong>。这可能违反了我们对磁盘的认知，因为在我们的印象中，写磁盘总是很慢。其实不然，准确地说应该是<strong>随机写磁盘很慢</strong>，因为在写之前可能会进行多次寻址。如果只是顺序写磁盘，性能是非常的高，如下的一个ACM报告中显示，顺序写磁盘甚至比随机写内存的性能还要高！</p>
<blockquote>
<p>举个例子，Kafka是一个高性能的消息队列，它的厉害之处就在于极致地利用磁盘的顺序写入性能，如果生产者和消费者的速率相当，消息甚至可以在操作系统的Page Cache层面就完成了传递。所以，以后别再认为写磁盘很慢了！</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwogc7lybj30g908ytaa.jpg" alt=""  /></p>
<p><strong>append-only log</strong>大幅提升了数据写入性能，但是随之而来的是，非常低的数据读取性能。针对这一点，我们采用Hash索引进行了优化，优化的效果也非常的显著。然而，Hash索引有两个明显的限制：（1）当key的数量很多时，维护Hash索引会给内存带来很大的压力；（2）区间查询很低效。<em>如何对这两个限制进行优化呢</em>？这就轮到本文介绍的主角，<strong>LSM树</strong>，出场了。</p>
<p><strong>LSM树</strong>（Log-Structured Merge Tree）并不是一种数据结构，准确来说是一种存储模型，由MemTable、Immutable MemTable、SSTable等部分组成。它也是利用了append-only log的优势，大幅提升了写入性能。同时，因为key的存储有序性，所以具备了不错的读取性能，也克服了上文所述Hash索引的两个限制。下面，本文将一步步分析LSM树是如何做到这一点的。</p>
<h2 id="sstable">SSTable</h2>
<p>在最简单的数据库例子中，因为数据是无序存储的，所以在读取某个key的值时，就需要遍历整个数据文件，算法复杂度是O(n)。为了提升读性能，我们不得不在内存中维护所有key的Hash索引。</p>
<p><em>假如存储数据时，对记录按照key进行排序的会怎样？</em></p>
<p>对于key有序存储这种情况，即使不用Hash索引，也能得到很好的查询效率，因为我们可以使用<strong>二分查找法</strong>（Binary Search）来快速找到key所在的位置，算法复杂度是O(logn)。<strong>LSM树正是采用key有序这种方式来组织数据存储的，并称之为SSTable。</strong></p>
<p><strong>SSTable</strong>（Sorted String Table）是LSM树最基础的一个存储结构，存储在磁盘中，并且数据按照key进行排序的。数据保持key有序的好处是可以在O(logn)的时间下，快速找到一个key值，相比于纯粹的append-only log有了很大的提升。但是，如果所有的数据都存储在一个SSTable上，数据量一大，查询效率也会下降。因此，LSM树通常会将数据分散存储在多个SSTable中，并且记录每个SSTable的最大key和最小key，这样就能快速定位到一个key存储在哪个SSTable上了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5yxrwjhej31ee0n2hdu.jpg" alt="SSTable数据查找示例"  /></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// SSTable，数据保存到SSTable后只读不写
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SSTable</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// 数据存储路径
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">LogFile</span> <span class="n">logFile</span><span class="o">;</span>
    <span class="c1">// 该SStable中存储的最小Key
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">String</span> <span class="n">minKey</span><span class="o">;</span>
    <span class="c1">// 该SStable中存储的最大Key
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">String</span> <span class="n">maxKey</span><span class="o">;</span>
    <span class="c1">// 使用二分查找法获取key值
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// step1：先判断是否在SSTable的范围内
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">minKey</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">maxKey</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// step2：二分查找
</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">logFile</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
            <span class="c1">// 先找到一条record到起始offset
</span><span class="c1"></span>            <span class="kt">long</span> <span class="n">startOffset</span> <span class="o">=</span> <span class="n">logFile</span><span class="o">.</span><span class="na">startOffsetOf</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">record</span> <span class="o">=</span> <span class="n">logFile</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">startOffset</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">midKey</span> <span class="o">=</span> <span class="n">Util</span><span class="o">.</span><span class="na">keyOf</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">midKey</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">Util</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">midKey</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 找到一条record到起始offset时可能会有mid == start的情况
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">mid</span> <span class="o">==</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
    <span class="o">}</span>
		<span class="o">...</span>
<span class="o">}</span>
</code></pre></div><blockquote>
<p>这里只是介绍了一种比较简单的SSTable实现方式，实际上，各种LSM树存储引擎对SSTable的实现都有所差异，比如LevelDB就将SSTable划分成两大块，数据存储区存储key:value数据，数据管理区存储索引等数据。</p>
</blockquote>
<p><em>那么怎样才能保证SSTable的有序性呢？</em></p>
<p>类似的在磁盘中维护数据有序的存储结构最常见的当属<strong>B/B+树</strong>了，如果对SSTable也采用类似的存储结构，那么带来的第一个问题就是每次写入都会伴随着磁盘的随机写，从而影响了数据的写入性能，这明显就违反了LSM树的初衷。为了同时兼顾SSTable的有序性以及写入性能，LSM树采用了<strong>MemTable</strong>这一组件。</p>
<h2 id="memtable">MemTable</h2>
<p>相比于磁盘上维护一个有序的数据结构，在内存上实现数据有序要简单得多，而且具备较高的读写性能，常见的有序数据结构有红黑树、AVL树、跳表等，不管你插入的顺序如何，读出来的数据总是有序的。<strong>MemTable</strong>正是LSM维护在内存中的一个有序的数据结构，接下来我们看下LSM是如何利用Memtable做到同时兼顾SSTable的有序行和写入性能的：</p>
<p>1、当写入请求过来时，先将record写入到Memtable中，这样就能保证record在内存中有序了，而且具备较高的写入性能。</p>
<p>2、当Memtable的大小达到一定的阈值后（通常是几个Mb的大小），将MemTable转成<strong>Immutable MemTable</strong>（一个只读不写的MemTable），并创建新的MemTable接收写请求。</p>
<blockquote>
<p>和《从Hash索引到LSM树（一）》中的segment file机制类似，一个时刻只有current segment file接收写请求，其他的只读不写。</p>
</blockquote>
<p>3、通过后台任务，定时将Immutable MemTable的数据刷到SSTable中，<strong>因为Immutable MemTable本身的有序性，所以就能保证SSTable中的数据是有序的，而且数据写入SSTable文件时完全是顺序写入，做到了有序性和写入性能的兼顾。</strong></p>
<p>4、当读请求过来时，查找的顺序是MemTable-&gt;Immutable MemTable-&gt;SSTable，找到则返回，否则一步步执行下去。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh435q2rk1j31a80tox6q.jpg" alt="Memtable同时兼顾有序和写性能"  /></p>
<p>Memtable底层通常采用跳表来实现（LevelDB、HBase都采用了这一实现方法），相比较AVL和红黑树，跳表在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率很高，而且实现起来也更简单些。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// LSM维护在内存中的有序数据结构，数据写入时先写MemTable
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemTable</span> <span class="o">{</span>
    <span class="c1">// 基于跳表实现的key-value结构
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ConcurrentSkipListMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">cache</span><span class="o">;</span>
    <span class="c1">// 当前存储数据的大小
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">AtomicInteger</span> <span class="n">size</span><span class="o">;</span>
		<span class="o">...</span>
    <span class="c1">// 查找key
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 添加key:value，并更新当前Memtable的大小
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="n">size</span><span class="o">.</span><span class="na">addAndGet</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// 返回当前Memtable的大小（字节为单位）
</span><span class="c1"></span>    <span class="c1">// 用于判断达到阈值之后，转成Immutable MemTable
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 达到阈值之后转储到SSTable
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">compact2Sst</span><span class="o">(</span><span class="n">SSTable</span> <span class="n">sst</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">sst</span><span class="o">::</span><span class="n">add</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div><h2 id="lsmkvdb">LsmKvDb</h2>
<p>使用LSM树作为存储引擎的数据库，通常对SSTable进行分层管理，方便查询以及后续的Compact操作。本文也将采用对SSTable进行分层的架构实现<strong>LsmKvDb</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4pweaflyj31am0qkhdu.jpg" alt="LsmKvDb存储架构"  /></p>
<p>首先对Level进行抽象，每个Level都由多个SSTable组成：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 对LSM的层的抽象，由SSTable组成
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Level</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">SSTable</span><span class="o">&gt;</span> <span class="n">ssts</span><span class="o">;</span>
	  <span class="o">...</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">SSTable</span> <span class="n">sst</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ssts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sst</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 在当前level中查找key对应的value, 从老到新遍历所有SSTable
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">find</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ssts</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ssts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// sst与当前level进行compact操作
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">compactWith</span><span class="o">(</span><span class="n">SSTable</span> <span class="n">sst</span><span class="o">)</span> <span class="o">{...}</span>

    <span class="c1">// 对给定sst集合与当前level进行compact操作
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">compactWith</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">SSTable</span><span class="o">&gt;</span> <span class="n">ssts</span><span class="o">)</span> <span class="o">{...}</span>
<span class="o">}</span>
</code></pre></div><p>LsmKvDb的实现代码如下，写数据时写入MemTable，当达到阈值后转Immutable MemTable。Immutable MemTable与MemTable具有相同的数据结构，唯一不同的是前者只读不写，后者既读也写。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 基于LSM树的key-value数据库, 采用分层架构
</span><span class="cm"> * MemTable -&gt; Immutable MemTable -&gt; Level0 -&gt; Level1 -&gt; Level2
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LsmKvDb</span> <span class="kd">implements</span> <span class="n">KvDb</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// 存储SSTable的目录
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">sstDir</span><span class="o">;</span>
    <span class="c1">// 当前写入的MemTable
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">MemTable</span> <span class="n">memTable</span><span class="o">;</span>
    <span class="c1">// MemTable到达阈值大小后转储到immutableMts
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">MemTable</span><span class="o">&gt;</span> <span class="n">immutableMts</span><span class="o">;</span>
    <span class="c1">// 后台定时将immutableMts中的MemTable刷到Level0，各SSTable之间可能由Key重叠
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Level</span> <span class="n">level0</span><span class="o">;</span>
    <span class="c1">// 后台定时将Level0中的SSTable与Level1中的进行合并
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Level</span> <span class="n">level1</span><span class="o">;</span>
    <span class="c1">// 当Level1中的SSTable的数量到达一定阈值后，选择最老的SSTable与Level2中的进行合并
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Level</span> <span class="n">level2</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// step1: 从MemTable中读取
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">memTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// step2: 从Immutable MemTable中读取，从新到老
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">immutableMts</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">immutableMts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// step3: 从Level0中读取
</span><span class="c1"></span>        <span class="n">value</span> <span class="o">=</span> <span class="n">level0</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// step4: 从Level1中读取
</span><span class="c1"></span>        <span class="o">...</span>
        <span class="c1">// step5: 从Level2中读取
</span><span class="c1"></span>        <span class="o">...</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">memTable</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="c1">// 当MemTable大小到达阈值后转成Immutable MemTable
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">memTable</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">MEMTABLE_MAX_SIZE</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">immutableMts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">memTable</span><span class="o">);</span>
                <span class="n">memTable</span> <span class="o">=</span> <span class="n">MemTable</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
		<span class="o">...</span>
<span class="o">}</span>
</code></pre></div><h2 id="compaction">Compaction</h2>
<p>上一篇文章《从Hash索引到LSM树（一）》已经对Compaction机制已经有了讲解，其目的是清除掉已经被覆写或删除了的记录，避免数据存储文件无休止的增长下去。对于LSM树而言，该机制同样适用，随着数据的不断添加、更新和删除，一些SSTable之间必然存在着重叠的key或被删除的key。通过Compaction，可以将多个SSTable合并成一个，从而节省了磁盘空间。</p>
<blockquote>
<p>在上篇文章中，对segment file的compact操作主要依赖于Hash索引。因为是索引覆盖全部的key，所以可以很容易通过新的segment file的Hash索引来判断该key是否已经被处理过。但对于SSTable而言，并没有覆盖全部key的Hash索引，那么如何进行compact才高效呢？</p>
<p>得益于SSTable的有序性，我们可以应用<strong>归并排序算法</strong>来进行compact操作！</p>
</blockquote>
<p>LSM树的Compaction通常有三种类型，分别是<strong>minor compact</strong>、<strong>major compact</strong>和<strong>full compact</strong>。</p>
<h3 id="minor-compact">Minor Compact</h3>
<p>minor compact指的是将Immutable MemTable中的数据直接转存到Level0中的SSTable。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4uzy9xfrj316e0gee81.jpg" alt="minor compact"  /></p>
<p>因为是直接将各个Immutable MemTable的数据转储成SSTable，并没有做合并的操作，因此在Level0中，各个SSTable之间的key可能存在重叠的现象。</p>
<h3 id="major-compact">Major Compact</h3>
<p>major compact指的是将Level n中的SSTable合并到Level n+1中。</p>
<p><em>Level0 -&gt; Level1的合并步骤如下：</em></p>
<p>1、选中Level0中的最老的SSTable <code>sst0</code>，然后在Level0中找到与<code>sst0</code> 的key存在重叠的所有SSTable <code>sst0...n</code>。</p>
<p>2、在Level1中，选取所有与 <code>sst0...n</code>存在key重叠的SSTable <code>sst'0...m</code>。</p>
<p>3、对<code>sst0...n</code>和<code>sst'0...m</code>采用<strong>多路归并排序算法</strong>进行合并，得到新的<code>sst‘’0...k</code>，并存储在Level1中。</p>
<p>4、删除<code>sst0...n</code>和<code>sst'0...m</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4vqc6p0gj31a60pge82.jpg" alt="major compact Level0 -&amp;gt; Level1"  /></p>
<p>不同于Level0，Level1和Level2中各个SSTable之间并不存在key重叠的现象，因此Level1 -&gt; Level2的合并会稍微简单些。</p>
<p><em>Level1 -&gt; Level2的合并步骤如下：</em></p>
<p>1、选中Level1中的最老的SSTable <code>sst0</code>。</p>
<p>2、在Level2中，选取所有与 <code>sst0</code>存在key重叠的SSTable <code>sst'0...m</code>。</p>
<p>3、对<code>sst0</code>和<code>sst'0...m</code>采用<strong>多路归并排序算法</strong>进行合并，得到新的<code>sst‘’0...k</code>，并存储在Level2中。</p>
<p>4、删除<code>sst0</code>和<code>sst'0...m</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4vr49h0ij31a20pqe82.jpg" alt="major compact Level1 -&amp;gt; Level2"  /></p>
<h3 id="full-compact">Full Compact</h3>
<p>full compact指的是对Level0、Level1、Level2中所有的SSTable进行compact操作，同样也是采用多路归并排序算法。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4vwpb10fj316o0oq1ky.jpg" alt="full compact"  /></p>
<p>通常full compact耗时较多，所以一般都会选择在流量较少的时刻进行。</p>
<h2 id="优化lsm树">优化LSM树</h2>
<h3 id="为sstable引入block">为SSTable引入block</h3>
<p>到目前为止，对于在一个SSTable中查找一个key，我们首先会根据min key和max key判断该key是否属于该SSTable所属的范围，如果属于，则对SSTable采用二分查找法进行搜索。二分查找之所以在LsmKvDb中行得通，是因为这是一个简单的SSTable实现 —— 数据按<code>string</code>存储和<code>\n</code>分隔。在实际的运用中，为了尽可能地利用磁盘空间，SSTable中数据通常都是以字节码的形式存储，也不会以<code>\n</code>分隔每条record，这种情况下采用二分查找的实现就比较复杂了，而且效率也会太高。</p>
<p>一个常见的优化方法是，<strong>在SSTable中对record按照一定的size组织成多个block，并以block为单位进行压缩</strong>。为了能够快速找到某个key所属的block，需要在内存中维护每个block的起始key对应在SSTable中的offset（一个稀疏的Hash索引）。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4wbuw1idj31ao0scnpe.jpg" alt="按block存储的SSTable"  /></p>
<p><em>在查找key的步骤如下：</em></p>
<p>1、根据索引定位到key所属的block。</p>
<p>2、将该block加载到内存中，并解压。</p>
<p>3、对内存中的数据采用二分查找。</p>
<blockquote>
<p>在设计block的大小时，应该利用磁盘的空间局部性原理，使得系统能够只花费一次磁盘I/O就能将整个block加载到内存中。</p>
</blockquote>
<h3 id="为sstable引入bloom-filter">为SSTable引入Bloom Filter</h3>
<p>其实当目标key属于某个SSTable的key范围时，该key也不一定会存在于该SSTable中。但是到目前为止，只要目标key在某个SSTable的范围内，LsmKvDb都会进行查找操作。随着系统中的SSTable数目的增多，查询效率必然会随之下降。</p>
<p>一个常见的优化方法时，<strong>为SSTable引入布隆过滤器Bloom Filter</strong>。</p>
<p>Bloom Filter是保存在内存中的一种数据结构，可以用来告诉你 “<strong>某样东西一定不存在或者可能存在</strong>”。它由一个超长的二进制位数组和一系列的Hash函数组成。二进制位数组初始全部为0，当有元素加入集合时，这个元素会被一系列Hash函数计算映射出一系列的值，所有的值在位数组的偏移量处置为1。如果需要判断某个元素是否存在于集合当中，只需判断该元素被Hash后的值在数组中的值，如果存在为0的，则该元素一定不存在；如果全为1，则可能存在，这种情况可能有误判。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4wnac3toj313y0hghdt.jpg" alt="Bloom Filter"  /></p>
<p>通过Bloom Filter，我们可以很快就能判断目标key是否<strong>不存在于SSTable中</strong>，从而提升了读性能。</p>
<blockquote>
<p>Google的Guava库就提供了一个BloomFilter的实现，并且可以按需来设置误判率。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>本文承接上《从Hash索引到LSM树（一）》，主要介绍了LSM树的基本原理，并且在原来append-only log的基础上实现了一个简单的基于LSM树的key-value数据库LsmKvDb。LSM树主要由MemTable、Immutable MemTable、SSTable组成，其中MemTable和Immutable MemTable在内存中维护，而SSTable则存储在磁盘中。SSTable的有序性使得LSM树在无需Hash索引的情况下具有不错的读取性能，而且支持区间查询；而Memable则使得LSM树具备很高的写入性能。</p>
<p>本系列文章，我们从一个最简单的key-value数据库起步，一步步通过Hash索引、LSM树、布隆过滤器等技术手段对其进行了优化，从中也深入分析了各个技术点的实现原理。但数据库的索引技术远不止这些，比如最常用到的<strong>B/B+树</strong>，也是非常值得深入学习的，以后有机会再对其进行深入分析.</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/java/">Java</a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/">数据库索引</a>
        
            <a href="/tags/lsm/">LSM</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>CC BY 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/%E4%BB%8Ehash%E7%B4%A2%E5%BC%95%E5%88%B0lsm%E6%A0%91%E4%B8%80/">
        
        

        <div class="article-details">
            <h2 class="article-title">从Hash索引到LSM树（一）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/java%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8Boop-klass%E6%A8%A1%E5%9E%8B%E4%BA%8C/">
        
        

        <div class="article-details">
            <h2 class="article-title">Java的对象模型——Oop-Klass模型（二）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/java%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8Boop-klass%E6%A8%A1%E5%9E%8B%E4%B8%80/">
        
        

        <div class="article-details">
            <h2 class="article-title">Java的对象模型——Oop-Klass模型（一）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82java%E7%9A%84%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/">
        
        

        <div class="article-details">
            <h2 class="article-title">彻底弄懂Java的移位操作符</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <script src="https://utteranc.es/client.js" 
        repo="ruanrunxue/yrunz-comments"
        issue-term="pathname"
        
        label="yrunz"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.body.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>

    

    <footer class="site-footer">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    <section class="copyright">
        &copy;
        
            2019 -
        
        2023 元闰子的邀请
    </section>

    <section class="powerby">
        

        <a href="https://beian.miit.gov.cn/">粤ICP备19152659号 | </a>Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.3.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
        <br />
    </section>
</footer>

<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
